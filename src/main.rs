//! MCP Gateway - Universal Model Context Protocol Gateway
//!
//! Single-port multiplexing with Meta-MCP for ~95% context token savings.

use std::path::Path;
use std::process::ExitCode;
use std::sync::Arc;

use clap::Parser;
use tracing::{error, info};

use mcp_gateway::{
    capability::{
        AuthTemplate, CapabilityExecutor, CapabilityLoader, OpenApiConverter,
        parse_capability_file, validate_capability,
    },
    cli::{CapCommand, Cli, Command},
    config::Config,
    discovery::AutoDiscovery,
    gateway::Gateway,
    registry::Registry,
    setup_tracing,
    validator::{
        AgentUxValidator, OutputFormat, ValidateConfig,
        ConflictDetectionRule, NamingConsistencyRule,
    },
};

#[tokio::main]
async fn main() -> ExitCode {
    let cli = Cli::parse();

    // Setup tracing
    if let Err(e) = setup_tracing(&cli.log_level, cli.log_format.as_deref()) {
        eprintln!("Failed to setup tracing: {e}");
        return ExitCode::FAILURE;
    }

    // Handle subcommands
    match cli.command {
        Some(Command::Init {
            output,
            with_examples,
        }) => run_init_command(&output, with_examples),
        Some(Command::Cap(cap_cmd)) => run_cap_command(cap_cmd).await,
        Some(Command::Stats { url, price }) => run_stats_command(&url, price).await,
        Some(Command::Validate {
            paths,
            format,
            severity,
            fix,
            no_color,
        }) => {
            let config = ValidateConfig {
                format,
                min_severity: severity,
                auto_fix: fix,
                color: !no_color,
            };
            run_validate_command(&paths, &config).await
        }
        Some(Command::Serve) | None => run_server(cli).await,
    }
}

/// Generate a starter gateway configuration file.
///
/// Writes a commented YAML configuration to `output` that includes sensible
/// defaults and, when `with_examples` is true, three free-tier capability
/// definitions (weather, Wikipedia, Hacker News) so the user can start
/// experimenting immediately.
fn run_init_command(output: &Path, with_examples: bool) -> ExitCode {
    if output.exists() {
        eprintln!(
            "Error: {} already exists. Remove it first or choose a different path with --output.",
            output.display()
        );
        return ExitCode::FAILURE;
    }

    let examples_section = if with_examples {
        r#"
# Capabilities - direct REST API integration (no MCP server needed)
# These free capabilities work out of the box with zero API keys.
capabilities:
  enabled: true
  directories:
    - capabilities

# Example MCP backends (uncomment to enable)
# backends:
#   filesystem:
#     command: "npx -y @anthropic/mcp-server-filesystem /path/to/dir"
#     description: "File system access"
#   brave-search:
#     command: "npx -y @anthropic/mcp-server-brave-search"
#     description: "Web search via Brave"
#     env:
#       BRAVE_API_KEY: "${BRAVE_API_KEY}"
"#
    } else {
        r#"
# Capabilities - direct REST API integration
capabilities:
  enabled: true
  directories:
    - capabilities

# Add your MCP backends here:
# backends:
#   my-server:
#     command: "npx -y @my/mcp-server"
#     description: "My MCP server"
"#
    };

    let config_content = format!(
        r#"# MCP Gateway Configuration
# ========================
# Generated by: mcp-gateway init
#
# Documentation: https://github.com/MikkoParkkola/mcp-gateway#readme

# Server settings
server:
  host: "127.0.0.1"
  port: 3000

# Meta-MCP mode - exposes 4 meta-tools for dynamic tool discovery
# Reduces context tokens by ~95% compared to loading all tools upfront
meta_mcp:
  enabled: true
  cache_tools: true
  cache_ttl: 300s
{examples_section}"#
    );

    match std::fs::write(output, config_content) {
        Ok(()) => {
            println!("Created {}", output.display());
            println!();
            println!("Next steps:");
            println!("  1. Review and edit {}", output.display());
            println!("  2. Start the gateway:");
            println!("     mcp-gateway -c {}", output.display());
            println!("  3. Add to your MCP client (e.g. Claude Desktop):");
            println!("     {{");
            println!("       \"mcpServers\": {{");
            println!("         \"gateway\": {{");
            println!("           \"url\": \"http://127.0.0.1:3000/mcp\"");
            println!("         }}");
            println!("       }}");
            println!("     }}");
            ExitCode::SUCCESS
        }
        Err(e) => {
            eprintln!("Error: Failed to write {}: {e}", output.display());
            ExitCode::FAILURE
        }
    }
}

/// Run stats command
async fn run_stats_command(url: &str, price: f64) -> ExitCode {
    use serde_json::json;

    let client = reqwest::Client::new();
    let request_body = json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
            "name": "gateway_get_stats",
            "arguments": {
                "price_per_million": price
            }
        }
    });

    let url = format!("{}/mcp", url.trim_end_matches('/'));

    match client.post(&url).json(&request_body).send().await {
        Ok(response) => {
            if !response.status().is_success() {
                eprintln!("‚ùå Gateway returned error: {}", response.status());
                return ExitCode::FAILURE;
            }

            match response.json::<serde_json::Value>().await {
                Ok(body) => {
                    if let Some(result) = body.get("result") {
                        if let Some(content) = result.get("content") {
                            if let Some(arr) = content.as_array() {
                                if let Some(first) = arr.first() {
                                    if let Some(text) = first.get("text").and_then(|v| v.as_str()) {
                                        if let Ok(stats) = serde_json::from_str::<serde_json::Value>(text) {
                                            println!("üìä Gateway Statistics\n");
                                            println!("Invocations:       {}", stats["invocations"]);
                                            println!("Cache Hits:        {}", stats["cache_hits"]);
                                            println!("Cache Hit Rate:    {}", stats["cache_hit_rate"]);
                                            println!("Tools Discovered:  {}", stats["tools_discovered"]);
                                            println!("Tools Available:   {}", stats["tools_available"]);
                                            println!("Tokens Saved:      {}", stats["tokens_saved"].as_u64().unwrap_or(0));
                                            println!("Estimated Savings: {}", stats["estimated_savings_usd"]);

                                            if let Some(top_tools) = stats["top_tools"].as_array() {
                                                if !top_tools.is_empty() {
                                                    println!("\nüèÜ Top Tools:");
                                                    for tool in top_tools {
                                                        println!("  ‚Ä¢ {}:{} - {} calls",
                                                            tool["server"].as_str().unwrap_or(""),
                                                            tool["tool"].as_str().unwrap_or(""),
                                                            tool["count"]);
                                                    }
                                                }
                                            }
                                            return ExitCode::SUCCESS;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if let Some(error) = body.get("error") {
                        eprintln!("‚ùå Error: {}", error.get("message").and_then(|v| v.as_str()).unwrap_or("Unknown"));
                        return ExitCode::FAILURE;
                    }

                    eprintln!("‚ùå Unexpected response format");
                    ExitCode::FAILURE
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to parse response: {e}");
                    ExitCode::FAILURE
                }
            }
        }
        Err(e) => {
            eprintln!("‚ùå Failed to connect to gateway: {e}");
            eprintln!("   Make sure the gateway is running at {url}");
            ExitCode::FAILURE
        }
    }
}

/// Collect YAML capability files from a list of paths (files or directories).
fn collect_capability_files(paths: &[std::path::PathBuf]) -> Vec<std::path::PathBuf> {
    let mut files = Vec::new();

    for path in paths {
        if path.is_file() {
            let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
            if ext == "yaml" || ext == "yml" {
                files.push(path.clone());
            }
        } else if path.is_dir() {
            collect_yaml_recursive(path, &mut files);
        } else {
            eprintln!("Warning: skipping non-existent path: {}", path.display());
        }
    }

    files
}

/// Recursively collect YAML files from a directory.
fn collect_yaml_recursive(dir: &std::path::Path, files: &mut Vec<std::path::PathBuf>) {
    let Ok(entries) = std::fs::read_dir(dir) else {
        return;
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            collect_yaml_recursive(&path, files);
        } else if path.is_file() {
            let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
            if ext == "yaml" || ext == "yml" {
                files.push(path);
            }
        }
    }
}

/// Format a validation report as human-readable text with optional color.
fn format_validate_text(
    file_results: &[(&str, &mcp_gateway::validator::ValidationReport)],
    config: &ValidateConfig,
) -> String {
    use std::fmt::Write;

    let mut output = String::new();

    let pass_marker = if config.color { "\x1b[32mPASS\x1b[0m" } else { "PASS" };
    let warn_marker = if config.color { "\x1b[33mWARN\x1b[0m" } else { "WARN" };
    let fail_marker = if config.color { "\x1b[31mFAIL\x1b[0m" } else { "FAIL" };

    let mut total_pass = 0usize;
    let mut total_warn = 0usize;
    let mut total_fail = 0usize;

    for &(file_path, report) in file_results {
        let _ = writeln!(output, "\n--- {file_path} ---");

        for result in &report.results {
            // Apply severity filter
            if !config.min_severity.includes(result.severity) {
                continue;
            }

            let marker = if result.passed {
                total_pass += 1;
                pass_marker
            } else if result.severity == mcp_gateway::validator::Severity::Fail {
                total_fail += 1;
                fail_marker
            } else {
                total_warn += 1;
                warn_marker
            };

            let _ = writeln!(
                output,
                "  [{marker}] [{}] {} - {}",
                result.rule_code, result.tool_name, result.rule_name
            );

            if !result.passed {
                for issue in &result.issues {
                    let _ = writeln!(output, "         {issue}");
                }
            }
        }
    }

    let _ = writeln!(output);
    let _ = writeln!(
        output,
        "Summary: {total_pass} passed, {total_warn} warnings, {total_fail} failures"
    );

    output
}

/// Run the validate command against one or more capability paths.
#[allow(clippy::too_many_lines)]
async fn run_validate_command(
    paths: &[std::path::PathBuf],
    config: &ValidateConfig,
) -> ExitCode {
    let files = collect_capability_files(paths);

    if files.is_empty() {
        eprintln!("No YAML capability files found in the given paths.");
        return ExitCode::from(2);
    }

    let validator = AgentUxValidator::new();
    let mut all_tools = Vec::new();
    let mut file_reports: Vec<(String, mcp_gateway::validator::ValidationReport)> = Vec::new();
    let mut has_failures = false;
    let mut parse_errors = false;

    // Phase 1: Parse and validate each file
    for file in &files {
        let cap = match parse_capability_file(file).await {
            Ok(c) => c,
            Err(e) => {
                eprintln!("Parse error in {}: {e}", file.display());
                parse_errors = true;
                continue;
            }
        };

        let tool = cap.to_mcp_tool();
        let report = match validator.validate_tools(std::slice::from_ref(&tool)) {
            Ok(r) => r,
            Err(e) => {
                eprintln!("Validation error for {}: {e}", file.display());
                continue;
            }
        };

        if !report.failures().is_empty() {
            has_failures = true;
        }

        // Auto-fix if requested
        if config.auto_fix {
            let suggested = mcp_gateway::validator::fix::CapabilityFixer::suggest_fixes(&report.results);
            if !suggested.is_empty() {
                if let Ok(content) = std::fs::read_to_string(file) {
                    if let Some(patched) = mcp_gateway::validator::fix::CapabilityFixer::apply_fixes(&content, &suggested) {
                        if std::fs::write(file, patched).is_ok() {
                            eprintln!("Auto-fixed {} issue(s) in {}", suggested.len(), file.display());
                        }
                    }
                }
            }
        }

        all_tools.push(tool);
        file_reports.push((file.display().to_string(), report));
    }

    // Phase 2: Cross-capability checks
    let conflict_results = ConflictDetectionRule::check_conflicts(&all_tools);
    let consistency_results = NamingConsistencyRule::check_consistency(&all_tools);

    let has_cross_failures = conflict_results.iter().any(|r| !r.passed && r.severity == mcp_gateway::validator::Severity::Fail)
        || consistency_results.iter().any(|r| !r.passed && r.severity == mcp_gateway::validator::Severity::Fail);

    if has_cross_failures {
        has_failures = true;
    }

    // Phase 3: Output
    match config.format {
        OutputFormat::Text => {
            let refs: Vec<(&str, &mcp_gateway::validator::ValidationReport)> = file_reports
                .iter()
                .map(|(p, r)| (p.as_str(), r))
                .collect();

            print!("{}", format_validate_text(&refs, config));

            // Print cross-capability results
            if !conflict_results.is_empty() || !consistency_results.is_empty() {
                println!("\n--- Cross-Capability Checks ---");
                for result in conflict_results.iter().chain(consistency_results.iter()) {
                    if !config.min_severity.includes(result.severity) {
                        continue;
                    }
                    let marker = if result.passed {
                        if config.color { "\x1b[32mPASS\x1b[0m" } else { "PASS" }
                    } else {
                        match result.severity {
                            mcp_gateway::validator::Severity::Fail => {
                                if config.color { "\x1b[31mFAIL\x1b[0m" } else { "FAIL" }
                            }
                            _ => {
                                if config.color { "\x1b[33mWARN\x1b[0m" } else { "WARN" }
                            }
                        }
                    };
                    println!("  [{marker}] [{}] {} - {}", result.rule_code, result.tool_name, result.rule_name);
                    for issue in &result.issues {
                        println!("         {issue}");
                    }
                }
            }
        }

        OutputFormat::Json => {
            let json_output: Vec<serde_json::Value> = file_reports
                .iter()
                .map(|(path, report)| {
                    serde_json::json!({
                        "file": path,
                        "score": report.overall_score,
                        "grade": report.grade,
                        "results": report.results,
                        "summary": report.summary,
                    })
                })
                .collect();

            let full = serde_json::json!({
                "files": json_output,
                "cross_capability": {
                    "conflicts": conflict_results,
                    "consistency": consistency_results,
                },
            });

            println!("{}", serde_json::to_string_pretty(&full).unwrap_or_default());
        }

        OutputFormat::Sarif => {
            let file_result_refs: Vec<(&str, &[mcp_gateway::validator::ValidationResult])> = file_reports
                .iter()
                .map(|(p, r)| (p.as_str(), r.results.as_slice()))
                .collect();

            let sarif = mcp_gateway::validator::sarif::to_sarif_multi(&file_result_refs);
            println!("{}", serde_json::to_string_pretty(&sarif).unwrap_or_default());
        }
    }

    if parse_errors {
        ExitCode::from(2)
    } else if has_failures {
        ExitCode::FAILURE
    } else {
        ExitCode::SUCCESS
    }
}

/// Run capability management commands
#[allow(clippy::too_many_lines)]
async fn run_cap_command(cmd: CapCommand) -> ExitCode {
    match cmd {
        CapCommand::Validate { file } => match parse_capability_file(&file).await {
            Ok(cap) => {
                if let Err(e) = validate_capability(&cap) {
                    eprintln!("‚ùå Validation failed: {e}");
                    return ExitCode::FAILURE;
                }
                println!("‚úÖ {} - valid", cap.name);
                if !cap.description.is_empty() {
                    println!("   {}", cap.description);
                }
                if let Some(provider) = cap.primary_provider() {
                    println!(
                        "   Provider: {} ({})",
                        provider.service, provider.config.method
                    );
                    println!(
                        "   URL: {}{}",
                        provider.config.base_url, provider.config.path
                    );
                }
                if cap.auth.required {
                    println!("   Auth: {} ({})", cap.auth.auth_type, cap.auth.key);
                }
                ExitCode::SUCCESS
            }
            Err(e) => {
                eprintln!("‚ùå Failed to parse: {e}");
                ExitCode::FAILURE
            }
        },

        CapCommand::List { directory } => {
            let path = directory.to_string_lossy();
            match CapabilityLoader::load_directory(&path).await {
                Ok(caps) => {
                    if caps.is_empty() {
                        println!("No capabilities found in {path}");
                    } else {
                        println!("Found {} capabilities in {}:\n", caps.len(), path);
                        for cap in caps {
                            let auth_info = if cap.auth.required {
                                format!(" [{}]", cap.auth.auth_type)
                            } else {
                                String::new()
                            };
                            println!("  {} - {}{}", cap.name, cap.description, auth_info);
                        }
                    }
                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to load: {e}");
                    ExitCode::FAILURE
                }
            }
        }

        CapCommand::Import {
            spec,
            output,
            prefix,
            auth_key,
        } => {
            let mut converter = OpenApiConverter::new();

            if let Some(p) = prefix {
                converter = converter.with_prefix(&p);
            }

            if let Some(key) = auth_key {
                converter = converter.with_default_auth(AuthTemplate {
                    auth_type: "bearer".to_string(),
                    key,
                    description: "API authentication".to_string(),
                });
            }

            let spec_path = spec.to_string_lossy();
            match converter.convert_file(&spec_path) {
                Ok(caps) => {
                    let out_path = output.to_string_lossy();
                    println!("Generated {} capabilities from {}\n", caps.len(), spec_path);

                    for cap in caps {
                        if let Err(e) = cap.write_to_file(&out_path) {
                            eprintln!("‚ùå Failed to write {}: {e}", cap.name);
                        } else {
                            println!("  ‚úÖ {}.yaml", cap.name);
                        }
                    }

                    println!("\nCapabilities written to {out_path}/");
                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to convert: {e}");
                    ExitCode::FAILURE
                }
            }
        }

        CapCommand::Test { file, args } => {
            // Parse capability
            let cap = match parse_capability_file(&file).await {
                Ok(c) => c,
                Err(e) => {
                    eprintln!("‚ùå Failed to parse capability: {e}");
                    return ExitCode::FAILURE;
                }
            };

            // Parse arguments
            let params: serde_json::Value = match serde_json::from_str(&args) {
                Ok(v) => v,
                Err(e) => {
                    eprintln!("‚ùå Invalid JSON arguments: {e}");
                    return ExitCode::FAILURE;
                }
            };

            println!("Testing capability: {}", cap.name);
            println!(
                "Arguments: {}",
                serde_json::to_string_pretty(&params).unwrap_or_default()
            );
            println!();

            // Execute
            let executor = Arc::new(CapabilityExecutor::new());
            match executor.execute(&cap, params).await {
                Ok(result) => {
                    println!("‚úÖ Success:\n");
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&result).unwrap_or_default()
                    );
                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("‚ùå Execution failed: {e}");
                    ExitCode::FAILURE
                }
            }
        }

        CapCommand::Discover {
            format,
            write_config,
            config_path,
        } => {
            let discovery = AutoDiscovery::new();

            println!("üîç Discovering MCP servers...\n");

            match discovery.discover_all().await {
                Ok(servers) => {
                    if servers.is_empty() {
                        println!("No MCP servers found.");
                        println!("\nSearched locations:");
                        println!("  ‚Ä¢ Claude Desktop config");
                        println!("  ‚Ä¢ VS Code/Cursor MCP configs");
                        println!("  ‚Ä¢ Windsurf config");
                        println!("  ‚Ä¢ ~/.config/mcp/*.json");
                        println!("  ‚Ä¢ Running processes (pieces, surreal, etc.)");
                        println!("  ‚Ä¢ Environment variables (MCP_SERVER_*_URL)");
                        return ExitCode::SUCCESS;
                    }

                    match format.as_str() {
                        "json" => {
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&servers).unwrap_or_default()
                            );
                        }
                        "yaml" => {
                            println!(
                                "{}",
                                serde_yaml::to_string(&servers).unwrap_or_default()
                            );
                        }
                        _ => {
                            // Table format
                            println!("Discovered {} MCP server(s):\n", servers.len());
                            for server in &servers {
                                println!("üì¶ {}", server.name);
                                println!("   Description: {}", server.description);
                                println!("   Source: {:?}", server.source);

                                match &server.transport {
                                    mcp_gateway::config::TransportConfig::Stdio {
                                        command,
                                        ..
                                    } => {
                                        println!("   Transport: stdio");
                                        println!("   Command: {command}");
                                    }
                                    mcp_gateway::config::TransportConfig::Http {
                                        http_url,
                                        ..
                                    } => {
                                        println!("   Transport: http");
                                        println!("   URL: {http_url}");
                                    }
                                }

                                if let Some(ref path) = server.metadata.config_path {
                                    println!("   Config: {}", path.display());
                                }
                                if let Some(pid) = server.metadata.pid {
                                    println!("   PID: {pid}");
                                }

                                println!();
                            }
                        }
                    }

                    if write_config {
                        println!("\nüìù Writing discovered servers to config...");
                        let result = write_discovered_to_config(&servers, config_path.as_deref());
                        match result {
                            Ok(path) => {
                                println!("‚úÖ Config written to {}", path.display());
                                println!(
                                    "\nTo use discovered servers, start gateway with: mcp-gateway -c {}",
                                    path.display()
                                );
                            }
                            Err(e) => {
                                eprintln!("‚ùå Failed to write config: {e}");
                                return ExitCode::FAILURE;
                            }
                        }
                    } else {
                        println!("\nüí° To add these servers to your gateway config, run:");
                        println!("   mcp-gateway cap discover --write-config");
                    }

                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("‚ùå Discovery failed: {e}");
                    ExitCode::FAILURE
                }
            }
        }

        CapCommand::Install {
            name,
            from_github,
            repo,
            branch,
            output,
        } => {
            if from_github {
                println!("üì¶ Installing {name} from GitHub ({repo})...");
                let registry = Registry::new(&output);
                match registry
                    .install_from_github(&name, &repo, &branch)
                    .await
                {
                    Ok(path) => {
                        println!("‚úÖ Installed to {}", path.display());
                        ExitCode::SUCCESS
                    }
                    Err(e) => {
                        eprintln!("‚ùå Installation failed: {e}");
                        ExitCode::FAILURE
                    }
                }
            } else {
                // All capabilities are already in the capabilities directory
                println!("‚ÑπÔ∏è  All capabilities are already available in the capabilities directory.");
                println!("   Use 'cap list' to see available capabilities.");
                ExitCode::SUCCESS
            }
        }

        CapCommand::Search { query, capabilities } => {
            let reg = Registry::new(&capabilities);
            match reg.build_index().await {
                Ok(index) => {
                    let results = index.search(&query);
                    if results.is_empty() {
                        println!("No capabilities found matching '{query}'");
                    } else {
                        println!("Found {} capability(ies) matching '{query}':\n", results.len());
                        for entry in results {
                            let auth = if entry.requires_key { " üîë" } else { "" };
                            println!("  {} - {}{}", entry.name, entry.description, auth);
                            if !entry.tags.is_empty() {
                                println!("    Tags: {}", entry.tags.join(", "));
                            }
                            println!();
                        }
                        println!("All capabilities are already available in the capabilities directory.");
                    }
                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to build registry index: {e}");
                    ExitCode::FAILURE
                }
            }
        }

        CapCommand::RegistryList { capabilities } => {
            let reg = Registry::new(&capabilities);
            match reg.build_index().await {
                Ok(index) => {
                    println!("Available capabilities ({}):\n", index.capabilities.len());
                    for entry in &index.capabilities {
                        let auth = if entry.requires_key { " üîë" } else { "" };
                        println!("  {} - {}{}", entry.name, entry.description, auth);
                        if !entry.tags.is_empty() {
                            println!("    Tags: {}", entry.tags.join(", "));
                        }
                        println!();
                    }
                    println!("All capabilities are available in the capabilities directory.");
                    ExitCode::SUCCESS
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to build registry index: {e}");
                    ExitCode::FAILURE
                }
            }
        }
    }
}

/// Apply CLI overrides to a loaded configuration.
///
/// Merges CLI-provided port, host, and meta-mcp settings into `config`.
fn apply_cli_overrides(config: &mut Config, cli: &Cli) {
    if let Some(port) = cli.port {
        config.server.port = port;
    }
    if let Some(ref host) = cli.host {
        config.server.host.clone_from(host);
    }
    if cli.no_meta_mcp {
        config.meta_mcp.enabled = false;
    }
}

/// Run the gateway server
async fn run_server(cli: Cli) -> ExitCode {
    // Load configuration
    let config = match Config::load(cli.config.as_deref()) {
        Ok(mut config) => {
            apply_cli_overrides(&mut config, &cli);
            config
        }
        Err(e) => {
            error!("Failed to load configuration: {e}");
            return ExitCode::FAILURE;
        }
    };

    info!(
        version = env!("CARGO_PKG_VERSION"),
        port = config.server.port,
        backends = config.backends.len(),
        meta_mcp = config.meta_mcp.enabled,
        "Starting MCP Gateway"
    );

    // Create and run gateway
    let gateway = match Gateway::new(config).await {
        Ok(g) => g,
        Err(e) => {
            error!("Failed to create gateway: {e}");
            return ExitCode::FAILURE;
        }
    };

    // Run with graceful shutdown
    if let Err(e) = gateway.run().await {
        error!("Gateway error: {e}");
        return ExitCode::FAILURE;
    }

    info!("Gateway shutdown complete");
    ExitCode::SUCCESS
}

/// Write discovered servers to a config file
fn write_discovered_to_config(
    servers: &[mcp_gateway::discovery::DiscoveredServer],
    config_path: Option<&std::path::Path>,
) -> mcp_gateway::Result<std::path::PathBuf> {

    // Determine config path
    let path = if let Some(p) = config_path {
        p.to_path_buf()
    } else {
        std::path::PathBuf::from("mcp-gateway-discovered.yaml")
    };

    // Load existing config or create new
    let mut config = if path.exists() {
        Config::load(Some(&path))?
    } else {
        Config::default()
    };

    // Add discovered servers to backends
    for server in servers {
        let backend_config = server.to_backend_config();
        config.backends.insert(server.name.clone(), backend_config);
    }

    // Serialize to YAML
    let yaml = serde_yaml::to_string(&config)
        .map_err(|e| mcp_gateway::Error::Config(format!("Failed to serialize config: {e}")))?;

    // Write to file
    std::fs::write(&path, yaml)
        .map_err(|e| mcp_gateway::Error::Config(format!("Failed to write config: {e}")))?;

    Ok(path)
}

#[cfg(test)]
mod tests {
    use super::*;
    use mcp_gateway::cli::Cli;
    use mcp_gateway::config::Config;

    /// Build a `Cli` struct with optional overrides for testing.
    fn make_cli(
        port: Option<u16>,
        host: Option<String>,
        no_meta_mcp: bool,
    ) -> Cli {
        Cli {
            config: None,
            port,
            host,
            log_level: "info".to_string(),
            log_format: None,
            no_meta_mcp,
            command: None,
        }
    }

    // =====================================================================
    // apply_cli_overrides
    // =====================================================================

    #[test]
    fn apply_cli_overrides_no_overrides_preserves_defaults() {
        let mut config = Config::default();
        let cli = make_cli(None, None, false);

        let original_port = config.server.port;
        let original_host = config.server.host.clone();
        let original_meta = config.meta_mcp.enabled;

        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.port, original_port);
        assert_eq!(config.server.host, original_host);
        assert_eq!(config.meta_mcp.enabled, original_meta);
    }

    #[test]
    fn apply_cli_overrides_port_override() {
        let mut config = Config::default();
        let cli = make_cli(Some(9999), None, false);

        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.port, 9999);
    }

    #[test]
    fn apply_cli_overrides_host_override() {
        let mut config = Config::default();
        let cli = make_cli(None, Some("0.0.0.0".to_string()), false);

        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.host, "0.0.0.0");
    }

    #[test]
    fn apply_cli_overrides_disable_meta_mcp() {
        let mut config = Config::default();
        assert!(config.meta_mcp.enabled); // default is enabled

        let cli = make_cli(None, None, true);
        apply_cli_overrides(&mut config, &cli);

        assert!(!config.meta_mcp.enabled);
    }

    #[test]
    fn apply_cli_overrides_all_at_once() {
        let mut config = Config::default();
        let cli = make_cli(Some(8080), Some("192.168.1.1".to_string()), true);

        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.port, 8080);
        assert_eq!(config.server.host, "192.168.1.1");
        assert!(!config.meta_mcp.enabled);
    }

    #[test]
    fn apply_cli_overrides_no_meta_mcp_false_keeps_enabled() {
        let mut config = Config::default();
        let cli = make_cli(None, None, false);

        apply_cli_overrides(&mut config, &cli);

        assert!(config.meta_mcp.enabled);
    }

    #[test]
    fn apply_cli_overrides_port_zero_is_valid() {
        let mut config = Config::default();
        let cli = make_cli(Some(0), None, false);

        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.port, 0);
    }

    #[test]
    fn apply_cli_overrides_host_empty_string() {
        let mut config = Config::default();
        let cli = make_cli(None, Some(String::new()), false);

        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.host, "");
    }

    #[test]
    fn apply_cli_overrides_preserves_other_config_fields() {
        let mut config = Config::default();
        config.backends.insert("test".to_string(), Default::default());
        config.server.request_timeout = std::time::Duration::from_secs(60);

        let cli = make_cli(Some(3000), None, false);
        apply_cli_overrides(&mut config, &cli);

        assert_eq!(config.server.port, 3000);
        assert!(config.backends.contains_key("test"));
        assert_eq!(
            config.server.request_timeout,
            std::time::Duration::from_secs(60)
        );
    }

    // =====================================================================
    // Config::default sanity checks
    // =====================================================================

    #[test]
    fn default_config_has_expected_defaults() {
        let config = Config::default();
        assert_eq!(config.server.port, 39400);
        assert_eq!(config.server.host, "127.0.0.1");
        assert!(config.meta_mcp.enabled);
        assert!(config.backends.is_empty());
    }

    // =====================================================================
    // run_init_command
    // =====================================================================

    #[test]
    fn init_command_creates_config_file() {
        let dir = tempfile::tempdir().unwrap();
        let output = dir.path().join("gateway.yaml");

        let result = run_init_command(&output, true);

        assert_eq!(result, ExitCode::SUCCESS);
        assert!(output.exists());

        let content = std::fs::read_to_string(&output).unwrap();
        assert!(content.contains("server:"));
        assert!(content.contains("host: \"127.0.0.1\""));
        assert!(content.contains("port: 3000"));
        assert!(content.contains("meta_mcp:"));
        assert!(content.contains("enabled: true"));
    }

    #[test]
    fn init_command_with_examples_includes_capabilities() {
        let dir = tempfile::tempdir().unwrap();
        let output = dir.path().join("gateway.yaml");

        let result = run_init_command(&output, true);

        assert_eq!(result, ExitCode::SUCCESS);
        let content = std::fs::read_to_string(&output).unwrap();
        assert!(content.contains("capabilities:"));
        assert!(content.contains("directories:"));
    }

    #[test]
    fn init_command_without_examples_omits_sample_backends() {
        let dir = tempfile::tempdir().unwrap();
        let output = dir.path().join("gateway.yaml");

        let result = run_init_command(&output, false);

        assert_eq!(result, ExitCode::SUCCESS);
        let content = std::fs::read_to_string(&output).unwrap();
        assert!(content.contains("capabilities:"));
        // Should not contain the filesystem/brave-search example backends
        assert!(!content.contains("filesystem:"));
    }

    #[test]
    fn init_command_refuses_to_overwrite_existing() {
        let dir = tempfile::tempdir().unwrap();
        let output = dir.path().join("gateway.yaml");
        std::fs::write(&output, "existing content").unwrap();

        let result = run_init_command(&output, true);

        assert_eq!(result, ExitCode::FAILURE);
        // Original content should be preserved
        let content = std::fs::read_to_string(&output).unwrap();
        assert_eq!(content, "existing content");
    }

    #[test]
    fn init_command_custom_output_path() {
        let dir = tempfile::tempdir().unwrap();
        let output = dir.path().join("custom-config.yaml");

        let result = run_init_command(&output, true);

        assert_eq!(result, ExitCode::SUCCESS);
        assert!(output.exists());
    }
}
